---
title: "Analyzing the Dissimilarity Indices for the PSRC region"
author: "Data Science"
date: "2021"
output:
  html_document:
    df_print: paged
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Does Single Family Zoning correlate with greater segregation?

The dissimilarity index was calculated at a block group level. The Future Land Use Layer was used to represent zoning with the field Max Dwelling Units per Acre. We are using this field to define single family zoning. The analysis found there is some correlation between single-family zoning and segregation. There is also a relationship between Max Dwelling Units and segregation over the entire range of Max DU. Lower Max Dwelling Units are associated with more white people, and Higher Max Dwelling Units are associated with more People of Color. The differing ranges of Max DUs per acre across the region makes it difficult to perform the analysis.
I couldn't easily find a way to communicate the info I uncovered to a policy board level audience.

From a technical standpoint, we are looking into:

### Does the Maximum Dwelling Units per Acre in a Block Group correlate with the Dissimilarity Index of the Block Group?

### 

The segregation measure is a set of dissimilarity indices between racial groups. Between any two groups a measure of dissimilarity is calculated for each block group. More documentation can be found here: <https://www.censusscope.org/about_dissimilarity.html>

```{r data_prep, echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
library(dplyr)
library(corrr)
library(writexl)
library(openxlsx)
library(ggplot2)
library(tidyverse)
library(sf)
library(leaflet)
library(tidyverse)
library(sf)
library(leaflet)
library(tidycensus)
library(writexl)
library(htmlwidgets)
library(Hmisc)
library(BAMMtools)
library(DBI)
library(odbc)
library(mapview)

setwd("~/GitHub/data-science/dissimilarity")


flu<- st_read('C:/Users/SChildress/Documents/ReferenceResearch/displacement/diss_flu16.shp')

flu_df<-as.data.frame(flu)
dissim_index <- read.csv('dissim_bg.csv')

flu_df$GEOID10<- as.numeric(flu_df$GEOID10)
flu_df<-flu_df%>%drop_na(GEOID10)

```

Because the future land use layer and the block groups do not match up geographically, I needed to do an aggregation to get a one to one match between the future land use and the block groups. For this, I found the max, min, and mean maximum du for a block group for all intersecting flu areas.

Then I looked into which aggregation max, min or mean of the max_du had the most correlation with the dissimilarity index; this will help us select which aggregation is the best for further analysis.

```{r stat_test, echo=FALSE}
flu_df<-flu_df%>%group_by(GEOID10)%>% arrange(desc(max_du_ac))%>%summarise(max_max_du=first(max_du_ac), min_max_du=last(max_du_ac), mean_max_du=mean(max_du_ac), median_max_du=median(max_du_ac))

# remove 0s, these represent geographic mismatches
flu_df <- flu_df %>% filter(max_max_du!=0)
flu_dissim<-merge(flu_df, dissim_index, by ="GEOID10")


cor.test(flu_dissim$White_Minority_Dissim, flu_dissim$mean_max_du,
         method = "spearman")


cor.test(flu_dissim$White_Minority_Dissim, flu_dissim$median_max_du,
         method = "spearman")

cor.test(flu_dissim$White_Minority_Dissim, flu_dissim$max_max_du,
         method = "spearman")

cor.test(flu_dissim$White_Minority_Dissim, flu_dissim$min_max_du,
         method = "spearman")


```

**The most correlation was observed between the dissimilarity index and the aggregation to the block group by mean**, so the rest of the analysis will use the mean max_du_ac by block group from the flu layer.

Let's analyze the distributions of the mean_max_du and the dissimilarity indices.

```{r summary_vars, echo=FALSE}

describe(flu_dissim$mean_max_du)

describe(flu_dissim$White_Minority_Dissim)

ggplot(flu_df,aes(x=mean_max_du))+geom_histogram(bins=100)+geom_vline(aes(xintercept=mean(mean_max_du, color=blue)))

breaks<-getJenksBreaks(flu_df$mean_max_du, k=10)
breaks


ggplot(flu_dissim, aes(x=White_Minority_Dissim)) + geom_histogram(bins=100)

```

There are long tails on the max dus. I'm going to cap them at 100. Then create some maps to look at both the max dus and the dissimilarity indices.

```{r more_analysis}

flu_dissim<- flu_dissim %>%mutate(mean_max_du_capped=replace(mean_max_du,mean_max_du>100,100))

ggplot(flu_dissim, aes(x=mean_max_du_capped)) + geom_histogram(bins=25)



```

```{r, echo=FALSE}
create_map_du <- function(c.layer,
                             map.title = NULL, map.subtitle = NULL,
                             map.title.position = NULL,
                             legend.title = NULL, legend.subtitle = NULL,
                             map.lat=47.615, map.lon=-122.257, map.zoom=8.5, wgs84=4326){
  


  # Calculate Bins from Data and create color palette


  pal <- leaflet::colorNumeric(palette="Purples", domain = c.layer$mean_max_du_capped)
  
  labels <- paste0(
                   'Max Du per Acre: ',c.layer$mean_max_du_capped) %>% lapply(htmltools::HTML)
  
  m <- leaflet::leaflet() %>%
    leaflet::addMapPane(name = "polygons", zIndex = 410) %>%
    leaflet::addMapPane(name = "maplabels", zIndex = 500) %>% # higher zIndex rendered on top
    
    leaflet::addProviderTiles("CartoDB.VoyagerNoLabels") %>%
    leaflet::addProviderTiles("CartoDB.VoyagerOnlyLabels",
                              options = leaflet::leafletOptions(pane = "maplabels"),
                              group = "Labels") %>%
    
    leaflet::addEasyButton(leaflet::easyButton(icon="fa-globe",
                                               title="Region",
                                               onClick=leaflet::JS("function(btn, map){map.setView([47.615,-122.257],8.5); }"))) %>%
    leaflet::addPolygons(data=c.layer,
                         fillOpacity = 0.7,
                         fillColor = pal(c.layer$mean_max_du_capped),
                         opacity = 0,
                         stroke=FALSE,
                         weight = 0.7,
                         color = "#BCBEC0",
                         group="Population",
                         options = leaflet::leafletOptions(pane = "polygons"),
                         dashArray = "",
                         highlight = leaflet::highlightOptions(
                           weight =5,
                           color = "76787A",
                           dashArray ="",
                           fillOpacity = 0.7,
                           bringToFront = TRUE),
                         label = labels,
                         labelOptions = leaflet::labelOptions(
                           style = list("font-weight" = "normal", padding = "3px 8px"),
                           textsize = "15px",
                           direction = "auto")) %>%
    
    leaflet::addLegend(pal = pal,
                       values = c.layer$mean_max_du_capped,
                       position = "bottomright",
                       title = paste(legend.title, '<br>', legend.subtitle)) %>%
    
    leaflet::addControl(html = paste(map.title, '<br>', map.subtitle),
                        position = map.title.position,
                        layerId = 'mapTitle') %>%
    
    leaflet::addLayersControl(baseGroups = "CartoDB.VoyagerNoLabels",
                              overlayGroups = c("Labels", "Population")) %>%
    
    leaflet::setView(lng=map.lon, lat=map.lat, zoom=map.zoom)
  
  return(m)
  
}
```
Now let's map the range of Max DU per acre.

MAX DU PER ACRE
```{r make_maps, echo=FALSE}
flu_dissim<-flu_dissim%>%mutate(GEOID10=as.character(GEOID10))
flu_dissim<-flu_dissim%>%drop_na(GEOID10)

gdb.nm <- paste0("MSSQL:server=",
                 "AWS-PROD-SQL\\Sockeye",
                 ";database=",
                 "ElmerGeo",
                 ";trusted_connection=yes")

spn <-  2285

bg_layer_name <- "dbo.BLOCKGRP2010_NOWATER"

bg.lyr <- st_read(gdb.nm, bg_layer_name, crs = spn)

wgs84=4326
c.layer <- dplyr::left_join(bg.lyr,flu_dissim, by = c("geoid10"="GEOID10")) %>%
  sf::st_transform(wgs84)
c.layer$mean_max_du_capped[is.na(c.layer$mean_max_du_capped)]<-0


flu_bg_map<-create_map_du(c.layer)

flu_bg_map
```





Minority-White Dissimilarity
```{r, echo=FALSE}
create_map_dissim <- function(c.layer,
                             map.title = NULL, map.subtitle = NULL,
                             map.title.position = NULL,
                             legend.title = NULL, legend.subtitle = NULL,
                             map.lat=47.615, map.lon=-122.257, map.zoom=8.5, wgs84=4326){
  


  # Calculate Bins from Data and create color palette
  rng <- range(c.layer$White_Minority_Dissim)


  
  pal <- leaflet::colorNumeric("Purples", domain = c.layer$White_Minority_Dissim, reverse=TRUE)
  
  labels <- paste0(
                   'White_Minority_Dissim: ',c.layer$White_Minority_Dissim, big.mark = ",") %>% lapply(htmltools::HTML)
  
  m <- leaflet::leaflet() %>%
    leaflet::addMapPane(name = "polygons", zIndex = 410) %>%
    leaflet::addMapPane(name = "maplabels", zIndex = 500) %>% # higher zIndex rendered on top
    
    leaflet::addProviderTiles("CartoDB.VoyagerNoLabels") %>%
    leaflet::addProviderTiles("CartoDB.VoyagerOnlyLabels",
                              options = leaflet::leafletOptions(pane = "maplabels"),
                              group = "Labels") %>%
    
    leaflet::addEasyButton(leaflet::easyButton(icon="fa-globe",
                                               title="Region",
                                               onClick=leaflet::JS("function(btn, map){map.setView([47.615,-122.257],8.5); }"))) %>%
    leaflet::addPolygons(data=c.layer,
                         fillOpacity = 0.7,
                         fillColor = pal(c.layer$White_Minority_Dissim),
                         opacity = 0,
                         stroke=FALSE,
                         weight = 0.7,
                         color = "#BCBEC0",
                         group="Population",
                         options = leaflet::leafletOptions(pane = "polygons"),
                         dashArray = "",
                         highlight = leaflet::highlightOptions(
                           weight =5,
                           color = "76787A",
                           dashArray ="",
                           fillOpacity = 0.7,
                           bringToFront = TRUE),
                         label = labels,
                         labelOptions = leaflet::labelOptions(
                           style = list("font-weight" = "normal", padding = "3px 8px"),
                           textsize = "15px",
                           direction = "auto")) %>%
    
    leaflet::addLegend(pal = pal,
                       values = c.layer$White_Minority_Dissim,
                       position = "bottomright",
                       title = paste(legend.title, '<br>', legend.subtitle)) %>%
    
    leaflet::addControl(html = paste(map.title, '<br>', map.subtitle),
                        position = map.title.position,
                        layerId = 'mapTitle') %>%
    
    leaflet::addLayersControl(baseGroups = "CartoDB.VoyagerNoLabels",
                              overlayGroups = c("Labels", "Population")) %>%
    
    leaflet::setView(lng=map.lon, lat=map.lat, zoom=map.zoom)
  
  return(m)
  
}

```
Looking at the allowed max du map and the Dissimiliarity map, the patterns between the two are not obvious.


```{r White_Black_Dissim}
c.layer$White_Minority_Dissim[is.na(c.layer$White_Minority_Dissim)]<-0
dissim_bg_map<-create_map_dissim(c.layer)
dissim_bg_map


```

These plots show the dissimiliarity index vs the max du.  Again they show a fairly weak relationship, but it is there.
```{r}

ggplot(flu_dissim, aes(x=mean_max_du_capped, y=White_Minority_Dissim))+
  geom_point()+
  geom_smooth(method=lm, formula='y ~poly(x,3)')

```

It looks like:

With max DUs ranging from 0 to 25, as the max DUs increases, the White-People of Color Dissimilarity decreases, and gets closer to 0, meaning less White shares, and more integration. The most integration is in the ranges of 25-75 DU per acre.

Also with max Dus ranging from 75 to 100 as the max DUs increases, the White-Black Dissimilarity decreases, and becomes more negative, meaning less White shares, but more segregation of People of Color (I think this is what it means).

If we want to define single family, we will need to use some thresholds to do so.  Here is an analysis of defining single family at 10 du per acre.  The average dissimiliarity index is more negative in non-single family zoned areas at -0.82 avg and more positive in single family zoned areas at 2.66 avg.

The differences are statistically significant between the groups.


```{r}

```



What if we try a multibreak point approach: 0-3 DUs low sf, 3-6 med sf, 6-10 high sf, 10-25 low mf, 25-75 med mf, 75+ high mf?




```{r, echo=FALSE}
  
low_sf<-3
med_high_sf<-10
low_mf<-25
med_mf<-75


# Add a variable for defining single family as greater than 0, but less than some max DU per acre
flu_dissim<-flu_dissim %>% mutate(sf_mf_cats = case_when(
    max_max_du<=low_sf ~ "Low_SF (less than 3 Du per acre)",
    max_max_du<=med_high_sf ~ "Med_High_SF (3-10)",
    max_max_du<=low_mf ~  "Low_MF (10-25)",
    max_max_du<=med_mf ~ "Med_MF(25-75)",
    max_max_du>=med_mf ~ "High_MF(75+)"
  ))

flu_dissim$sf_mf_cats <-factor(flu_dissim$sf_mf_cats, levels=c("Low_SF (less than 3 Du per acre)",
                                                               "Med_High_SF (3-10)",
                                                                "Low_MF (10-25)",
                                                               "Med_MF(25-75)",
                                                               "High_MF(75+)"))

flu_dissim %>% group_by(sf_mf_cats) %>% summarise(mean_dissim_white_minority=mean(White_Minority_Dissim))

du_cat_dissim<-ggplot(flu_dissim, aes(x=sf_mf_cats, y=White_Minority_Dissim))+geom_boxplot()



```

What if we simply estimate a linear model with the categorization of single family and multi-family?
```{r, echo=FALSE}
flu_dissim_model<-glm(White_Minority_Dissim ~ sf_mf_cats,
                 data=flu_dissim)

summary(flu_dissim_model)
```



Now do some analysis in Seattle only between the relationship of max_du and dissimiliarity.We'll do the correlation with max_du, the model with multiple categories.

```{r , echo=FALSE}
# connecting to Elmer
db.connect <- function() {
  elmer_connection <- dbConnect(odbc(),
                                driver = "SQL Server",
                                server = "AWS-PROD-SQL\\Sockeye",
                                database = "Elmer",
                                trusted_connection = "yes"
  )
}

# a function to read tables and queries from Elmer
read.dt <- function(astring, type =c('table_name', 'sqlquery')) {
  elmer_connection <- db.connect()
  if (type == 'table_name') {
    dtelm <- dbReadTable(elmer_connection, SQL(astring))
  } else {
    dtelm <- dbGetQuery(elmer_connection, SQL(astring))
  }
  dbDisconnect(elmer_connection)
  dtelm
}

block_group_city<-read.dt("select pd.block_group_geoid10 from small_areas.parcel_dim pd where pd.city_name_2020 = 'Seattle' group by pd.block_group_geoid10 order by pd.block_group_geoid10", 'sqlquery')



```

SEATTLE ONLY ANALYSIS

```{r seattle, echo=FALSE}
block_group_city <- block_group_city %>% mutate(block_group_geoid10 =as.character(block_group_geoid10))
flu_dissim_seattle<- dplyr::left_join(block_group_city,flu_dissim, by = c("block_group_geoid10"="GEOID10"))

cor.test(flu_dissim_seattle$White_Minority_Dissim, flu_dissim_seattle$mean_max_du,
         method = "spearman")
ggplot(flu_dissim_seattle, aes(x=mean_max_du_capped, y=White_Minority_Dissim))+
  geom_point()+
  geom_smooth(method=lm, formula='y ~poly(x,3)')

flu_dissim_seattle %>% group_by(sf_mf_cats) %>% summarise(mean_dissim_white_black=mean(White_Minority_Dissim))
ggplot(flu_dissim_seattle, aes(x=sf_mf_cats, y=White_Minority_Dissim))+geom_boxplot()         
flu_dissim_model_seattle<-glm(White_Minority_Dissim ~ sf_mf_cats,
                 data=flu_dissim)
summary(flu_dissim_seattle)





```


```


